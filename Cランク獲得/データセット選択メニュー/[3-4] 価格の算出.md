# 価格の算出

https://paiza.jp/works/mondai/data_structure/data_structure__dict_step4

<details><summary>Python3 解答</summary><br>

```python
N, M = map(int, input().split())
prices = {}
for _ in range(N):
    A, B = input().split()
    prices[A] = int(B)

for _ in range(M):
    S = input()
    if S in prices:
        print(prices[S])
    else:
        print(-1)
```

別解<br>
出力の部分には `dict.get(key, default)` を使っています。<br>
`dict.get(key, default)` は、`key` が辞書にあれば `key` に対する値を、なければ `default` を返します。<br>
`default` の部分を指定しなければ、`None` を返します。(デフォルトで `default=None` になっている。)<br>
参考: https://docs.python.org/ja/3/library/stdtypes.html#dict.get

```python
N, M = map(int, input().split())
prices = {}
for _ in range(N):
    A, B = input().split()
    prices[A] = int(B)

for _ in range(M):
    S = input()
    print(prices.get(S, -1))
```

別解2<br>
例えば `dict([('one', 1), ('two', 2), ('three', 3)])` とすると、`{'one': 1, 'two': 2, 'three': 3}` と同じになる。<br>
同様に、以下のように `dict()` を使っている。<br>
ただし、**これでは `B` がint型(整数型)ではなくstr型(文字列型)のままなので、後の扱いには気をつけなければならない**。今回は後で計算することなく出力するだけなので問題ない。<br>
参考: https://docs.python.org/ja/3.13/library/stdtypes.html#dict

また、出力の部分は三項演算子を用いて簡潔に表している。

```python
N, M = map(int, input().split())
prices = dict(tuple(input().split()) for _ in range(N))

for _ in range(M):
    S = input()
    print(prices[S] if S in prices else -1)
```

<br></details>

<details><summary>C++ 解答</summary><br>

`S` が `map` に含まれているかどうかは、`map.find(S) != map.end()` または `map.count(S)` がtrueであるかどうかにより判断できる。<br>
`prices.find(S) != prices.end()` は `prices.count(S)` でも良い。

```cpp
#include <iostream>
#include <map>
using namespace std;

int main() {
    int N, M, B;
    string A, S;
    map<string, int> prices;
    cin >> N >> M;
    for (int i = 0; i < N; i++) {
        cin >> A >> B;
        prices[A] = B;
    }
    
    for (int i = 0; i < M; i++) {
        cin >> S;
        if (prices.find(S) != prices.end()) {
            cout << prices[S] << endl;
        } else {
            cout << -1 <<endl;
        }
    }
}
```

別解<br>
上の解法では、`S` を2回探索することになるが、以下のコードであれば1回の探索で済む。

```cpp
#include <iostream>
#include <map>
using namespace std;

int main() {
    int N, M, B;
    string A, S;
    map<string, int> prices;
    cin >> N >> M;
    for (int i = 0; i < N; i++) {
        cin >> A >> B;
        prices[A] = B;
    }
    
    for (int i = 0; i < M; i++) {
        cin >> S;
        auto it = prices.find(S);
        if (it != prices.end()) {
            cout << it->second << endl;
        } else {
            cout << -1 << endl;
        }
    }
}
```

別解2<br>
今回、`A` が昇順に並んでいる必要はないため、`unordered_map` を使っても良い。<br>
さらに出力の部分では、三項演算子を用いることで簡略化している。

```cpp
#include <iostream>
#include <unordered_map>
using namespace std;

int main() {
    int N, M, B;
    string A, S;
    unordered_map<string, int> prices;
    cin >> N >> M;
    for (int i = 0; i < N; i++) {
        cin >> A >> B;
        prices[A] = B;
    }
    
    for (int i = 0; i < M; i++) {
        cin >> S;
        auto it = prices.find(S);
        cout << (it != prices.end() ? it->second : -1) << endl;
    }
}
```

<br></details>
